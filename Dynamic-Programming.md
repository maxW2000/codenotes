**动态规划问题的一般形式就是求最值** <br>
动态规划的核心思想就是穷举求最值，但是问题千变万化，穷举所有可行解其实并不是一件容易的事，需要你熟练掌握递归思维，**只有列出正确的「状态转移方程」**，才能正确地穷举。而且，你需要判断算法问题是否**具备「最优子结构」**，是否能够通过子问题的最值得到原问题的最值。另外，**动态规划问题存在「重叠子问题」**，如果暴力穷举的话效率会很低，**所以需要你使用「备忘录」或者「DP table」来优化穷举过程**，避免不必要的计算。<br>
**总结**:
1. 明确「状态」**原问题和子问题中会变化的变量** dp中的n
2. 明确「选择」**导致「状态」产生变化的行为** <br> 即什么会导致f(n-m)出现, 例如选硬币中m可以={1,2,5}因为状态是amount，当n=11时 他的子问题就是min(f(11-1), f(11-2), f(11-5)) <br> 再例如斐波那契数列 m一般=1,2 因为f(11)的子问题就是f(11-1)+f(11-2)
3. 定义 dp 数组/函数的含义 （dp数组是状态转移方程的**载体**，即在i状态下 状态转移方程的输出值，**状态转移方程会与dp有关 且会有一些额外的参数参与**）
<br> dp[n]就是在 状态 = n时刻的最优解的个数（题目要求我们计算的值）

**常见的动态规划代码是「自底向上」进行「递推」求解** <br>
从最底下、最简单、问题规模最小、已知结果的base case开始往上推，直到推到我们想要的答案

```
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

## 备忘录的作用 （dp数组）
可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个**子问题先去「备忘录」里查一查**，如果发现之前已经解决过这个问题了，直接**把答案拿出来用**，不要再耗时去计算了。
```
def fib(N: int) -> int:
    # 备忘录全初始化为 0
    memo = [0] * (N + 1)
    # 进行带备忘录的递归
    return dp(memo, N)

# 带着备忘录进行递归
def dp(memo: List[int], n: int) -> int:
    # base case
    if n == 0 or n == 1: return n
    # 已经计算过，不用再计算了
    if memo[n] != 0: return memo[n]
    memo[n] = dp(memo, n - 1) + dp(memo, n - 2)
    return memo[n]
```

## 选硬币问题
[322. Coin Change](https://leetcode.com/problems/coin-change/description/)
1.确定「状态」，也就是原问题和子问题中会变化的变量。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以**唯一的「状态」就是目标金额 amount**
2.确定「选择」，也就是**导致「状态」产生变化的行为**。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」
3.明确 dp 函数/数组的定义。我们这里讲的是自顶向下的解法，所以会有一个递归的 dp 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是**题目要求我们计算的量**。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量
